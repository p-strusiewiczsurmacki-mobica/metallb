package conversion

import (
	"go.universe.tf/metallb/internal/config"

	corev1 "k8s.io/api/core/v1"
	"sigs.k8s.io/yaml"
)

const (
// separator      = "---\n"
// autoGenComment = "# This was autogenerated by MetalLB's custom resource generator.\n"
// outputFileName = "resources.yaml"
)

var (
	resourcesNameSpace = "metallb-system"
	// inputDirPath       = "/var/input"
	// source             = flag.String("source", "./config.yaml", "name of the configmap file to convert")
	// onlyData           = flag.Bool("only-data", false, "set this to true if the input file contains only the ConfigMap's data field")
	// stdout             = flag.Bool("stdout", false, "set this to true to write to stdout")
)

func DecodeLegacyCM(cm corev1.ConfigMap) (*configFile, error) {
	cf := &configFile{}
	err := yaml.Unmarshal([]byte(cm.Data["config"]), cf)
	if err != nil {
		return nil, err
	}

	return cf, nil
}

func ResourcesFor(cf *configFile) (config.ClusterResources, error) {
	var r config.ClusterResources
	var err error

	r.BFDProfiles = bfdProfileFor(cf)
	r.Communities = communitiesFor(cf)
	r.Peers, err = peersFor(cf)
	if err != nil {
		return config.ClusterResources{}, err
	}

	r.Pools = ipAddressPoolsFor(cf)
	r.BGPAdvs = bgpAdvertisementsFor(cf)
	r.L2Advs = l2AdvertisementsFor(cf)

	return r, nil
}

func AddLegacyResources(first, second *config.ClusterResources) config.ClusterResources {
	out := addResources(nil, first)
	return addResources(&out, second)
}
